# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19pt6tMhJWKo75Hc8YYIYw-g-SOAHgMnQ

# ðŸ¼ Pandas Part 1 - Complete Beginner Part

## ðŸŽ¯ Learning Objectives

By the end of this notebook, you will:
- âœ… Understand what pandas is and why it's essential
- âœ… Work with Series (1D data structures)
- âœ… Work with DataFrames (2D data structures)
- âœ… Read data from CSV and Excel files
- âœ… Inspect data with head(), info(), describe()
- âœ… Select specific columns from DataFrames
- âœ… Filter rows based on conditions
- âœ… Sort data by columns

---

## ðŸš¨ Why Pandas Matters

Pandas is **THE** most important library for data analysis in Python.

**With pandas, you can:**
- ðŸ“Š **Load data** from CSV, Excel, databases, APIs
- ðŸ” **Explore data** quickly and efficiently
- ðŸ§¹ **Clean data** by handling missing values, duplicates
- ðŸ”„ **Transform data** with filters, sorting, grouping
- ðŸ“ˆ **Analyze data** to extract insights
- ðŸ’¾ **Export data** to various formats

** As 90% of data analytics work can be done using pandas!**
"""

# ============================================
# SETUP: Import Libraries
# ============================================

# Import pandas (conventionally imported as 'pd')
import pandas as pd
import numpy as np

# Check pandas version
print(f'âœ… Pandas version: {pd.__version__}')
print(f'âœ… NumPy version: {np.__version__}')

# Display settings for better output
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', 100)
pd.set_option('display.width', None)

# ============================================
# PART 1: PANDAS SERIES
# ============================================

# What is a Series?
# -----------------
# A Series is a ONE-DIMENSIONAL array-like object
# Think of it as a single column in Excel
#
# Key characteristics:
# - Has an index (like row numbers)
# - Can hold any data type (integers, strings, floats, etc.)
# - Similar to a Python list, but with superpowers!

"""## 1. Creating Series

Different ways to create a pandas Series.


"""

print('=' * 60)
print('CREATING SERIES')
print('=' * 60)

# Method 1: From a list
prices = pd.Series([29.99, 49.99, 19.99, 99.99, 39.99])
print('\nðŸ“Š Series from list:')
print(prices)

# Method 2: From a list with custom index
products = pd.Series(
    [29.99, 49.99, 19.99, 99.99, 39.99],
    index=['Shirt', 'Jeans', 'Socks', 'Jacket', 'Hat']
)
print('\nðŸ“Š Series with custom index:')
print(products)

# Method 3: From a dictionary
sales_dict = {'Jan': 1000, 'Feb': 1200, 'Mar': 1500, 'Apr': 1300}
monthly_sales = pd.Series(sales_dict)
print('\nðŸ“Š Series from dictionary:')
print(monthly_sales)

"""## 2. Accessing Series Data

Different ways to access elements in a Series.

"""

print('=' * 60)
print('ACCESSING SERIES DATA')
print('=' * 60)

# Using products Series from above
print('\nðŸ“Š Original Series:')
print(products)

# Access by position (like a list)
print(f'\nFirst item (by position): ${products[0]}')
print(f'Last item (by position): ${products[-1]}')

# Access by index label
print(f'\nShirt price (by label): ${products["Shirt"]}')
print(f'Jacket price (by label): ${products["Jacket"]}')

# Access multiple items (slicing)
print('\nFirst 3 items:')
print(products[:3])

print('\nSpecific items by labels:')
print(products[['Shirt', 'Jeans', 'Socks']])

"""## 3. Series Operations

Perform calculations and operations on Series.

"""

print('=' * 60)
print('SERIES OPERATIONS')
print('=' * 60)

# Basic statistics
print('\nðŸ“Š Statistics:')
print(f'Sum: ${products.sum():.2f}')
print(f'Mean: ${products.mean():.2f}')
print(f'Median: ${products.median():.2f}')
print(f'Min: ${products.min():.2f}')
print(f'Max: ${products.max():.2f}')
print(f'Std Dev: ${products.std():.2f}')

# Arithmetic operations (vectorized!)
print('\nðŸ“Š Prices with 20% discount:')
discounted = products * 0.8
print(discounted)

# Boolean filtering
print('\nðŸ“Š Products over $30:')
expensive = products[products > 30]
print(expensive)

# ============================================
# PART 2: PANDAS DATAFRAMES
# ============================================

# What is a DataFrame?
# --------------------
# A DataFrame is a TWO-DIMENSIONAL data structure
# Think of it as an Excel spreadsheet or SQL table
#
# Key characteristics:
# - Has rows and columns
# - Each column is a Series
# - Columns can have different data types
# - Most commonly used pandas object

"""## 4. Creating DataFrames

Different ways to create a pandas DataFrame.

"""

print('=' * 60)
print('CREATING DATAFRAMES')
print('=' * 60)

# Method 1: From a dictionary
data = {
    'Name': ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve'],
    'Age': [25, 30, 35, 28, 32],
    'City': ['New York', 'London', 'Paris', 'Tokyo', 'Berlin'],
    'Salary': [70000, 80000, 75000, 90000, 85000]
}

df = pd.DataFrame(data)
print('\nðŸ“Š DataFrame from dictionary:')
print(df)

# Method 2: From a list of dictionaries
employees = [
    {'Name': 'John', 'Age': 28, 'Department': 'IT'},
    {'Name': 'Sarah', 'Age': 32, 'Department': 'HR'},
    {'Name': 'Mike', 'Age': 35, 'Department': 'Sales'}
]

df2 = pd.DataFrame(employees)
print('\nðŸ“Š DataFrame from list of dictionaries:')
print(df2)

# Create a larger sample dataset for demonstrations
np.random.seed(42)

sample_data = {
    'employee_id': range(1, 51),
    'name': [f'Employee_{i}' for i in range(1, 51)],
    'age': np.random.randint(22, 60, 50),
    'department': np.random.choice(['Sales', 'IT', 'HR', 'Marketing', 'Finance'], 50),
    'salary': np.random.randint(40000, 120000, 50),
    'experience_years': np.random.randint(1, 20, 50),
    'performance_score': np.random.uniform(3.0, 5.0, 50).round(1)
}

employees_df = pd.DataFrame(sample_data)
print('\nðŸ“Š Sample employees dataset created!')
print(f'Shape: {employees_df.shape[0]} rows Ã— {employees_df.shape[1]} columns')

"""## 5. Reading CSV Files

The most common way to load data into pandas.

"""

print('=' * 60)
print('READING CSV FILES')
print('=' * 60)

# First, let's save our sample data as CSV
employees_df.to_csv('employees_data.csv', index=False)
print('\nâœ… Sample CSV file created: employees_data.csv')

# Read CSV file
df_from_csv = pd.read_csv('employees_data.csv')
print('\nðŸ“Š Data loaded from CSV:')
print(df_from_csv.head())

# Common parameters for read_csv()
print('\nðŸ’¡ Common read_csv() parameters:')
print('  - filepath: "data.csv"')
print('  - sep="," : Delimiter (comma by default)')
print('  - header=0 : Row number to use as column names')
print('  - index_col : Column to use as row labels')
print('  - usecols : List of columns to read')
print('  - nrows : Number of rows to read')

# Reading CSV with specific parameters
print('\nðŸ“Š Reading first 10 rows only:')
df_sample = pd.read_csv('employees_data.csv', nrows=10)
print(df_sample)

# Reading specific columns
print('\nðŸ“Š Reading specific columns only:')
df_subset = pd.read_csv('employees_data.csv', usecols=['name', 'department', 'salary'])
print(df_subset.head())

"""## 6. Reading Excel Files

Loading data from Excel spreadsheets.

"""

print('=' * 60)
print('READING EXCEL FILES')
print('=' * 60)

# Save as Excel file
employees_df.to_excel('employees_data.xlsx', index=False, sheet_name='Employees')
print('\nâœ… Sample Excel file created: employees_data.xlsx')

# Read Excel file
df_from_excel = pd.read_excel('employees_data.xlsx', sheet_name='Employees')
print('\nðŸ“Š Data loaded from Excel:')
print(df_from_excel.head())

# Common parameters for read_excel()
print('\nðŸ’¡ Common read_excel() parameters:')
print('  - filepath: "data.xlsx"')
print('  - sheet_name: Name or index of sheet to read')
print('  - header=0 : Row number for column names')
print('  - usecols : Columns to read')
print('  - nrows : Number of rows to read')

"""## 7. Data Inspection Methods

Essential methods to understand your data.

"""

print('=' * 60)
print('DATA INSPECTION: head()')
print('=' * 60)

# head() - View first N rows (default 5)
print('\nðŸ“Š First 5 rows:')
print(employees_df.head())

print('\nðŸ“Š First 10 rows:')
print(employees_df.head(10))

# tail() - View last N rows
print('\nðŸ“Š Last 5 rows:')
print(employees_df.tail())

print('=' * 60)
print('DATA INSPECTION: info()')
print('=' * 60)

# info() - Get dataset overview
print('\nðŸ“Š Dataset Information:')
employees_df.info()

print('\nðŸ’¡ What info() shows:')
print('  - Number of rows and columns')
print('  - Column names')
print('  - Data types of each column')
print('  - Non-null counts (helps find missing values)')
print('  - Memory usage')

print('=' * 60)
print('DATA INSPECTION: describe()')
print('=' * 60)

# describe() - Statistical summary
print('\nðŸ“Š Statistical Summary:')
print(employees_df.describe())

print('\nðŸ’¡ What describe() shows:')
print('  - count: Number of non-null values')
print('  - mean: Average value')
print('  - std: Standard deviation')
print('  - min: Minimum value')
print('  - 25%: First quartile')
print('  - 50%: Median')
print('  - 75%: Third quartile')
print('  - max: Maximum value')

# Additional useful inspection methods
print('=' * 60)
print('MORE INSPECTION METHODS')
print('=' * 60)

# Shape
print(f'\nðŸ“ Shape: {employees_df.shape}')
print(f'  Rows: {employees_df.shape[0]}')
print(f'  Columns: {employees_df.shape[1]}')

# Columns
print(f'\nðŸ“‹ Column names:')
print(employees_df.columns.tolist())

# Data types
print(f'\nðŸ”¤ Data types:')
print(employees_df.dtypes)

# Check for missing values
print(f'\nâš ï¸  Missing values:')
print(employees_df.isnull().sum())

# Check for duplicates
print(f'\nðŸ”„ Duplicate rows: {employees_df.duplicated().sum()}')

"""## 8. Selecting Columns

Different ways to select columns from a DataFrame.

"""

print('=' * 60)
print('SELECTING COLUMNS')
print('=' * 60)

# Method 1: Select single column (returns Series)
print('\nðŸ“Š Single column (names) - Returns Series:')
names = employees_df['name']
print(type(names))
print(names.head())

# Method 2: Select single column (returns DataFrame)
print('\nðŸ“Š Single column (names) - Returns DataFrame:')
names_df = employees_df[['name']]
print(type(names_df))
print(names_df.head())

# Method 3: Select multiple columns
print('\nðŸ“Š Multiple columns:')
subset = employees_df[['name', 'department', 'salary']]
print(subset.head())

# Using dot notation (works if column name has no spaces)
print('\nðŸ“Š Using dot notation:')
print(employees_df.department.head())

# Selecting columns by data type
print('\nðŸ“Š Select only numerical columns:')
numerical_cols = employees_df.select_dtypes(include=['int64', 'float64'])
print(numerical_cols.head())

print('\nðŸ“Š Select only object (string) columns:')
string_cols = employees_df.select_dtypes(include=['object'])
print(string_cols.head())

"""## 9. Filtering Rows with Conditions

Filter data based on conditions (like SQL WHERE clause).

"""

print('=' * 60)
print('FILTERING ROWS - SINGLE CONDITION')
print('=' * 60)

# Filter: Employees with salary > 70000
high_earners = employees_df[employees_df['salary'] > 70000]
print(f'\nðŸ“Š Employees earning > $70,000 ({len(high_earners)} found):')
print(high_earners.head())

# Filter: Employees in IT department
it_dept = employees_df[employees_df['department'] == 'IT']
print(f'\nðŸ“Š IT Department employees ({len(it_dept)} found):')
print(it_dept.head())

# Filter: Young employees (age <= 30)
young_employees = employees_df[employees_df['age'] <= 30]
print(f'\nðŸ“Š Employees aged 30 or younger ({len(young_employees)} found):')
print(young_employees.head())

print('=' * 60)
print('FILTERING ROWS - MULTIPLE CONDITIONS')
print('=' * 60)

# AND condition: Use & (both conditions must be True)
# High salary AND IT department
it_high_earners = employees_df[
    (employees_df['salary'] > 70000) &
    (employees_df['department'] == 'IT')
]
print(f'\nðŸ“Š IT employees earning > $70,000 ({len(it_high_earners)} found):')
print(it_high_earners)

# OR condition: Use | (at least one condition must be True)
# Sales OR Marketing department
sales_or_marketing = employees_df[
    (employees_df['department'] == 'Sales') |
    (employees_df['department'] == 'Marketing')
]
print(f'\nðŸ“Š Sales or Marketing employees ({len(sales_or_marketing)} found):')
print(sales_or_marketing.head())

# Complex condition
experienced_performers = employees_df[
    (employees_df['experience_years'] > 10) &
    (employees_df['performance_score'] >= 4.0)
]
print(f'\nðŸ“Š Experienced high performers ({len(experienced_performers)} found):')
print(experienced_performers)

print('=' * 60)
print('FILTERING WITH .isin()')
print('=' * 60)

# Filter for multiple values in one column
selected_depts = employees_df[employees_df['department'].isin(['IT', 'HR', 'Finance'])]
print(f'\nðŸ“Š Employees in IT, HR, or Finance ({len(selected_depts)} found):')
print(selected_depts.head(10))

print('=' * 60)
print('FILTERING WITH .between()')
print('=' * 60)

# Filter for values in a range
mid_career = employees_df[employees_df['experience_years'].between(5, 10)]
print(f'\nðŸ“Š Mid-career employees (5-10 years exp) ({len(mid_career)} found):')
print(mid_career.head())

print('=' * 60)
print('FILTERING WITH STRING METHODS')
print('=' * 60)

# Filter based on string patterns
# Find employees whose names start with 'Employee_1'
starts_with_1 = employees_df[employees_df['name'].str.startswith('Employee_1')]
print(f'\nðŸ“Š Names starting with "Employee_1" ({len(starts_with_1)} found):')
print(starts_with_1.head())

# Find employees whose names contain '5'
contains_5 = employees_df[employees_df['name'].str.contains('5')]
print(f'\nðŸ“Š Names containing "5" ({len(contains_5)} found):')
print(contains_5.head())

"""## 10. Sorting Data

Sort DataFrames by one or more columns.

"""

print('=' * 60)
print('SORTING DATA - SINGLE COLUMN')
print('=' * 60)

# Sort by salary (ascending - lowest to highest)
sorted_asc = employees_df.sort_values('salary')
print('\nðŸ“Š Sorted by salary (ascending):')
print(sorted_asc[['name', 'department', 'salary']].head())

# Sort by salary (descending - highest to lowest)
sorted_desc = employees_df.sort_values('salary', ascending=False)
print('\nðŸ“Š Sorted by salary (descending):')
print(sorted_desc[['name', 'department', 'salary']].head())

# Sort by age
sorted_by_age = employees_df.sort_values('age', ascending=False)
print('\nðŸ“Š Sorted by age (oldest first):')
print(sorted_by_age[['name', 'age', 'department']].head())

print('=' * 60)
print('SORTING DATA - MULTIPLE COLUMNS')
print('=' * 60)

# Sort by department, then by salary within each department
sorted_multi = employees_df.sort_values(['department', 'salary'], ascending=[True, False])
print('\nðŸ“Š Sorted by department, then salary (desc) within department:')
print(sorted_multi[['name', 'department', 'salary']].head(15))

# Sort by performance score (descending), then by experience
sorted_perf = employees_df.sort_values(
    ['performance_score', 'experience_years'],
    ascending=[False, False]
)
print('\nðŸ“Š Top performers with most experience:')
print(sorted_perf[['name', 'performance_score', 'experience_years', 'salary']].head())

print('=' * 60)
print('SORTING INDEX')
print('=' * 60)

# Sort by index
sorted_by_index = sorted_desc.sort_index()
print('\nðŸ“Š Sorted by index (back to original order):')
print(sorted_by_index.head())

# Note: sort_values() returns a new DataFrame (doesn't modify original)
print('\nðŸ’¡ Important:')
print('  - sort_values() returns a new sorted DataFrame')
print('  - Original DataFrame remains unchanged')
print('  - Use inplace=True to modify original: df.sort_values("col", inplace=True)')

"""## 11. Combining Operations

Chain multiple operations together for powerful data analysis.

"""

print('=' * 60)
print('COMBINING OPERATIONS')
print('=' * 60)

# Example 1: Filter, Select, and Sort
# Find top 5 highest-paid IT employees
top_it = (employees_df
          [employees_df['department'] == 'IT']
          [['name', 'salary', 'experience_years']]
          .sort_values('salary', ascending=False)
          .head(5))

print('\nðŸ“Š Top 5 highest-paid IT employees:')
print(top_it)

# Example 2: Complex analysis
# Find high performers in Sales with >5 years experience, sorted by salary
sales_stars = (employees_df
               [(employees_df['department'] == 'Sales') &
                (employees_df['performance_score'] >= 4.0) &
                (employees_df['experience_years'] > 5)]
               [['name', 'salary', 'experience_years', 'performance_score']]
               .sort_values('salary', ascending=False))

print('\nðŸ“Š High-performing experienced Sales employees:')
print(sales_stars)

# Example 3: Department analysis
print('\nðŸ“Š Average salary by department (top 3):')

dept_analysis = (employees_df
                 .groupby('department')['salary']
                 .mean()
                 .sort_values(ascending=False)
                 .head(3))

print(dept_analysis)

print('\nðŸ’¡ This preview shows groupby() - covered in Pandas Part 2!')

"""---

# ðŸ’ª Practice Exercises

Practice Problems from above objectives.

## Exercise 1: Create a Series

**Task:**
Create a Series of temperatures for a week:
- Monday: 72Â°F
- Tuesday: 75Â°F
- Wednesday: 68Â°F
- Thursday: 70Â°F
- Friday: 73Â°F
- Saturday: 78Â°F
- Sunday: 80Â°F

Then:
1. Calculate the average temperature
2. Find the hottest day
3. Find days with temperature > 73Â°F
"""

# Create temperature Series
temps = pd.Series(
    [72, 75, 68, 70, 73, 78, 80],
    index=['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
)

print('Weekly temperatures:')
print(temps)

# Average temperature
avg_temp = temps.mean()
print(f'\nAverage temperature: {avg_temp:.1f}Â°F')

# Hottest day
hottest_day = temps.idxmax()
hottest_temp = temps.max()
print(f'Hottest day: {hottest_day} at {hottest_temp}Â°F')

# Days > 73Â°F
hot_days = temps[temps > 73]
print(f'\nDays with temperature > 73Â°F:')
print(hot_days)

"""## Exercise 2: DataFrame Inspection

**Task:**
Using the `employees_df` dataset:
1. Display the first 7 rows
2. Show the dataset info
3. Get statistical summary
4. Find the shape of the dataset
5. List all column names

"""

# 1. First 7 rows
print('First 7 rows:')
print(employees_df.head(7))

# 2. Dataset info
print('\nDataset info:')
employees_df.info()

# 3. Statistical summary
print('\nStatistical summary:')
print(employees_df.describe())

# 4. Shape
print(f'\nShape: {employees_df.shape}')

# 5. Column names
print(f'\nColumns: {employees_df.columns.tolist()}')

"""## Exercise 3: Column Selection

**Task:**
From `employees_df`:
1. Select only the 'name' and 'salary' columns
2. Select all numerical columns
3. Create a new DataFrame with 'name', 'department', and 'performance_score'

"""

# 1. Name and salary
name_salary = employees_df[['name', 'salary']]
print('Name and Salary:')
print(name_salary.head())

# 2. All numerical columns
numerical = employees_df.select_dtypes(include=['int64', 'float64'])
print('\nNumerical columns:')
print(numerical.head())

# 3. Name, department, performance_score
selected = employees_df[['name', 'department', 'performance_score']]
print('\nSelected columns:')
print(selected.head())

"""## Exercise 4: Filtering Data

**Task:**
Filter `employees_df` to find:
1. Employees earning more than $80,000
2. Employees in the HR department
3. Employees with performance score >= 4.5
4. Young high earners (age < 35 AND salary > 75000)
5. Employees in either Marketing or Finance departments

"""

# 1. Salary > 80000
high_salary = employees_df[employees_df['salary'] > 80000]
print(f'Employees earning > $80,000: {len(high_salary)}')
print(high_salary[['name', 'salary']].head())

# 2. HR department
hr_dept = employees_df[employees_df['department'] == 'HR']
print(f'\nHR employees: {len(hr_dept)}')
print(hr_dept[['name', 'department']].head())

# 3. Performance >= 4.5
top_performers = employees_df[employees_df['performance_score'] >= 4.5]
print(f'\nTop performers: {len(top_performers)}')
print(top_performers[['name', 'performance_score']].head())

# 4. Young high earners
young_rich = employees_df[(employees_df['age'] < 35) & (employees_df['salary'] > 75000)]
print(f'\nYoung high earners: {len(young_rich)}')
print(young_rich[['name', 'age', 'salary']].head())

# 5. Marketing or Finance
marketing_finance = employees_df[employees_df['department'].isin(['Marketing', 'Finance'])]
print(f'\nMarketing or Finance: {len(marketing_finance)}')
print(marketing_finance[['name', 'department']].head())

"""## Exercise 5: Sorting Challenge

**Task:**
1. Sort employees by performance_score (highest to lowest)
2. Sort by department (A-Z), then by salary (highest to lowest)
3. Find the top 10 highest-paid employees
4. Find the 5 most experienced employees in the IT department

"""

# 1. Sort by performance_score
by_performance = employees_df.sort_values('performance_score', ascending=False)
print('Top performers:')
print(by_performance[['name', 'performance_score']].head())

# 2. Sort by department, then salary
dept_salary = employees_df.sort_values(['department', 'salary'], ascending=[True, False])
print('\nBy department and salary:')
print(dept_salary[['name', 'department', 'salary']].head(10))

# 3. Top 10 highest-paid
top_10_paid = employees_df.sort_values('salary', ascending=False).head(10)
print('\nTop 10 highest-paid:')
print(top_10_paid[['name', 'salary']])

# 4. Most experienced in IT
it_experienced = (employees_df[employees_df['department'] == 'IT']
                  .sort_values('experience_years', ascending=False)
                  .head(5))
print('\nMost experienced IT employees:')
print(it_experienced[['name', 'experience_years']])

"""## Exercise 6: Combined Operations

**Challenge Task:**
Create a report showing:
1. Top 5 performers in each department (performance_score >= 4.5)
2. Their name, department, salary, and performance score
3. Sorted by department, then by performance score (descending)

Hint: Use filtering, column selection, and sorting together!

"""

# Top 5 performers per department
top_performers_report = (employees_df
                         [employees_df['performance_score'] >= 4.5]
                         [['name', 'department', 'salary', 'performance_score']]
                         .sort_values(['department', 'performance_score'],
                                     ascending=[True, False]))

print('Top Performers Report:')
print(top_performers_report)

# Get exactly 5 per department
print('\nðŸ“Š Top 5 per department:')
for dept in employees_df['department'].unique():
    dept_top = (employees_df[employees_df['department'] == dept]
                [employees_df['performance_score'] >= 4.5]
                [['name', 'department', 'salary', 'performance_score']]
                .sort_values('performance_score', ascending=False)
                .head(5))
    if len(dept_top) > 0:
        print(f'\n--- {dept} ---')
        print(dept_top)

"""---

# ðŸŽ‰ Finished Beginner Part !

We have completed Beginner Pandas Part 1! Here's what we learned:

## ðŸŽ¯ Key Concepts Learned

### âœ… Series
- Create Series from lists and dictionaries
- Access elements by position and label
- Perform operations and calculations

### âœ… DataFrames
- Create DataFrames from various sources
- Understand 2D data structure
- Work with rows and columns

### âœ… Reading Data
- Load CSV files with `read_csv()`
- Load Excel files with `read_excel()`
- Use parameters for customized reading

### âœ… Data Inspection
- `head()` and `tail()` - View data
- `info()` - Dataset overview
- `describe()` - Statistical summary
- `shape`, `columns`, `dtypes` - Structure info

### âœ… Selecting Columns
- Single column selection
- Multiple column selection
- Select by data type

### âœ… Filtering Rows
- Single condition filters
- Multiple conditions (AND, OR)
- `.isin()` and `.between()` methods
- String pattern matching

### âœ… Sorting Data
- Sort by single column
- Sort by multiple columns
- Ascending and descending order

---

## ðŸš€ Next Steps

** Intermediate Pandas Part 2 objectives: **
- Adding and removing columns
- Handling missing values
- GroupBy operations
- Merging and joining DataFrames
- Advanced data manipulation

---

## ðŸ“š Quick Reference

```python
# Reading data
df = pd.read_csv('file.csv')
df = pd.read_excel('file.xlsx')

# Inspection
df.head()
df.info()
df.describe()

# Selection
df['column']
df[['col1', 'col2']]

# Filtering
df[df['col'] > 100]
df[(df['col1'] > 100) & (df['col2'] == 'value')]

# Sorting
df.sort_values('col')
df.sort_values(['col1', 'col2'], ascending=[True, False])
```



"""